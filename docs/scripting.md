## 22 Создание скриптов

!!! abstract ""
    [Основы](#221-основы) | [Пример сценария](#222-пример-сценария-bourne) | [Сценарии Python](#223-написание-сценариев-на-python) | [awk](#224-некоторые-команды-awk) | [sed](#225-некоторые-команды-sed) | [Регулярные выражения](#226-регулярные-выражения) | [Полезные команды](#227-некоторые-полезные-команды)

Оболочка Bourne (`/bin/sh`) присутствует во всех установках Unix, и скрипты, написанные на этом языке, являются переносимыми; `man 1 sh` хорошая справочная информация.

### 22.1 Основы

#### Переменные и аргументы

Присваивание с помощью `variable=value`, получение содержимого с помощью `$variable`

!!! example ""
    **MESSAGE="Привет, Мир"**                        - Присваивание строки  
    **PI=3.1415**                                    - Присваивание десятичного числа  
    **N=8**  
    **TWON=`expr $N * 2`**                           - Арифметическое выражение (только целые числа)  
    **TWON=$(($N * 2))**                             - Другой синтаксис  
    **TWOPI=`echo "$PI * 2" | bc -l`**               - Используйте bc для операций с плавающей точкой  
    **ZERO=`echo "c($PI/4)-sqrt(2)/2" | bc -l`**  

Аргументы командной строки:

!!! info ""
    **$0, $1, $2, ...**                              - $0 - сама команда  
    **$#**                                           - Количество аргументов  
    **$\***                                          - Все аргументы (также $@)  

Специальные переменные:

!!! info ""
    **$$**                                           - Текущий идентификатор процесса  
    **$?**                                           - Код возврата последней команды  

!!! example ""
    **<команда>**  
    **if [ $? != 0 ]; then**  
    &nbsp; **echo "команда завершилась с ошибкой"**  
    **fi**  

!!! info ""
    Особого внимания здесь заслуживает конструкция **${PWD##*/}**, которая берет полный путь до текущего каталога (переменная *\$PWD*) и удаляет из него первую часть вплоть до последнего слеша, оставляя, таким образом, только имя самого каталога.

!!! example ""
    **mypath=`pwd`**  
    **mypath=${mypath}/file.txt**  
    **echo ${mypath##*/}**                           - Показать только имя файла  
    **echo ${mypath%%.*}**                           - Полный путь без расширения  

!!! example ""
    **foo=/tmp/my.dir/filename.tar.gz**  
    **path = \${foo%/*}**                             - Полный путь без расширения  
    **var2=${var:=string}**                          - Использовать `var`, если установлено, в противном случае использовать `string` присвоить `string` переменной `var`, а затем переменной `var2`.  

!!! example ""
    **size=$(stat -c%s "$file")**                    - получить размер файла в сценарии Bourne  
    **filesize=${size:=-1}**  

#### Конструкции

!!! example "Показать содержимое файлов из вывода команды ls"
    **for file in `ls`**  
    **do**  
    &nbsp; **echo $file**  
    **done**  

!!! example "Однострочная запись, разрешения имен для двух доменнов: example.com и google.com"
    **for i in {example.com,google.com}; do dig ANY $i; done**

!!! example "Выполняет цикл 5 раз"
    **count=0**  
    **while [ $count -lt 5 ]; do**  
    &nbsp; **echo $count**  
    &nbsp; **sleep 1**  
    &nbsp; **count=$(($count + 1))**  
    **done**  

!!! example "Пример функции с поиском файлов по расширению"
    **myfunction() {**  
    &nbsp; **find . -type f -name "*.$1" -print**       - $1 - первый аргумент функции  
    **}**  
    **myfunction "txt"**  

!!! example "А это уже скрипт, кoторый запускает команду в ответ на изменение файлов в каталoге"
    **# while true; do inotifywait -r -e MODIFY <path> && <command> done**

#### Создание файла

!!! example "Многострочное перенапровление в файл"
    **MYHOME=/home/colin**  
    **cat > testhome.sh << _EOF**  
    *# Весь этот код помещается в файл testhome.sh*  
    **if [ -d "$MYHOME" ] ; then**  
    &nbsp; **echo $MYHOME существует**  
    **else**  
    &nbsp; **echo $MYHOME не существует**  
    **fi**  
    **_EOF**  
    **sh testhome.sh**  

### 22.2 Пример сценария Bourne

В качестве небольшого примера, вот скрипт, используемый для создания PDF-буклета из XHTML-документа:

!!! example "Этот скрипт создает книгу в формате PDF для печати на двухстороннем принтере"
    ```bash
    #!/bin/sh
    if [ $# -ne 1 ]; then                        # Проверяем аргумент
      echo 1>&2 "Использование: $0 HtmlFile"
      exit 1                                     # Ненулевое значение при ошибке
    fi
    
    file=$1                                      # Присваиваем имя файла
    fname=${file%.*}                             # Получаем только имя файла
    fext=${file#*.}                              # Получаем расширение файла
    
    prince $file -o $fname.pdf                   # от www.princexml.com
    pdftops -paper A4 -noshrink $fname.pdf $fname.ps # создаем постскриптовый буклет
    cat $fname.ps |psbook|psnup -Pa4 -2 |pstops -b "2:0,1U(21cm,29.7cm)" > $fname.book.ps
    
    ps2pdf13 -sPAPERSIZE=a4 -sAutoRotatePages=None $fname.book.ps $fname.book.pdf
                                                 # используем #a4 и #None в Windows!
    exit 0                                       # успешное завершение
    ```

### 22.3 Написание сценариев на Python

TO DO

### 22.4 Некоторые команды awk

Awk полезен для разделения полей, подобного cut, но более мощным способом. Для получения других примеров поиск в этом документе. См., например, [gnulamp.com](http://www.gnulamp.com/awk.html) и [one-liners для awk](http://student.northpark.edu/pemente/awk/awk1line.txt) несколько примеров.

!!! example ""
    **awk '{ print $2, $1 }' file**                  - Вывести и инвертировать первые два столбца  
    **awk '{printf("%5d : %s\n", NR,$0)}' file**     - Добавить номер строки слева  
    **awk '{print FNR "\t" $0}' files**              - Добавить номер строки справа  
    **awk NF test.txt**                              - удалить пустые строки (то же самое, что и grep '.')  
    **awk 'length > 80'**                            - вывести строки длиннее 80 символов)  

### 22.5 Некоторые команды sed

Хорошее введение и учебник по [sed](http://www.grymoire.com/Unix/Sed.html).

!!! example ""
    **sed 's/string1/string2/g'**                          - Заменить string1 на string2  
    **sed -i 's/wroong/wrong/g' *.txt**                    - Заменить повторяющееся слово с помощью g  
    **sed 's/\\(.*\\)1/\12/g'**                            - Изменить anystring1 на anystring2  
    **sed '/&lt;p&gt;/,/&lt;/p&gt;/d' t.xhtml**                     - Удалить строки, начинающиеся с `<p>` и заканчивающиеся `</p>`  
    **sed '/ \*#/d; /\^ \*\$/d'**                              - Удалить комментарии и пустые строки  
    **sed 's/[ \t]\*\$//'**                                  - Удалить конечные пробелы (используйте вкладку вместо \t)  
    **sed 's/\^[ \t]\*//;s/[ \t]\*$//'**                    - Удаление ведущих и завершающих пробелов  
    **sed 's/[\^\*]/[&amp;]/'**                              - Заключить первый символ в []  
    **sed = file | sed 'N;s/\n/\t/' &gt; file.num**        - Нумерация строк в файле  

### 22.6 Регулярные выражения

Некоторые базовые регулярные выражения, полезные также для sed. Для более подробной информации о синтаксисе основных регулярных выражений см. [Basic Regex Syntax](http://www.regular-expressions.info/reference.html).

!!! example ""
    **\[\\^\$.|?\*+()**                          - специальные символы, любой другой символ будет соответствовать самому себе  
    **\\**                                    - эскейпирование специальных символов и обработка их как литералов  
    **\***                                    - повтор предыдущего элемента ноль или более раз  
    **.**                                    - один символ, кроме символов переноса строки  
    **.***                                   - соответствует нулю или более символов  
    **^**                                    - соответствует началу строки/строки  
    **\$**                                    - соответствует концу строки/строки  
    **.\$**                                   - соответствует одному символу в конце строки/строки  
    **^ $**                                  - соответствует строке со своим единственным пробелом  
    **[^A-Z]**                               - соответствует строке, начинающейся с любого символа от A до Z  

### 22.7 Некоторые полезные команды

Следующие команды полезно включить в скрипт или использовать в однострочных командах.

!!! example ""
    **sort -t. -k1,1n -k2,2n -k3,3n -k4,4n**                               - Сортировка IPv4 адресов  
    **echo 'Test' | tr '[:lower:]' '[:upper:]'**                           - Преобразование регистра  
    **echo foo.bar | cut -d . -f 1**                                       - Возвращает foo  
    **PID=$(ps | grep script.sh | grep bin | awk '{print $1}')**           - PID запущенного скрипта  
    **PID=$(ps axww | grep [p]ing | awk '{print $1}')**                    - PID ping (без grep pid)  
    **IP=$(ifconfig $INTERFACE | sed '/.\*inet /!d;s///;s/ .\*/ /')**      - Linux  
    **IP=$(ifconfig $INTERFACE | sed '/.\*inet /!d;s///;s/ .\*/ /')**      - FreeBSD  
    **if [ `diff file1 file2 | wc -l` != 0 ]; then [...] fi**              - Изменен файл?  
    **cat /etc/master.passwd | grep -v root | grep -v \\\*: | awk -F":" \\** - Создание http-пароля  
    **'{ printf("%s:%s\n", $1, $2) }' &gt; /usr/local/etc/apache2/passwd**  
    **testuser=$(cat /usr/local/etc/apache2/passwd | grep -v \\**          - Проверка пользователя в файле паролей  
    **root | grep -v \\\*: | awk -F":" '{ printf("%s\n", $1) }' | grep ^user$)**  
    **tail +2 file &gt; file2**                                            - удалить первую строку из файла  

Используя этот маленький трюк, чтобы одновременно изменить расширение файла для множества файлов. Например, с .cxx на .cpp. Сначала протестируйте его без `| sh` в конце. Вы также можете сделать это с помощью команды `rename`, если она установлена. Или с помощью встроенных средств `bash`.

!!! example ""
    **# ls *.cxx | awk -F. '{print "mv "$0" "$1".cpp"}' | sh**  
    **# ls *.c | sed "s/.*/cp & &.$(date "+%Y%m%d")/" | sh**      - например, копирование `*.c` в `*.c.20080401`  
    **# rename .cxx .cpp *.cxx**                                  - Переименовать все `.cxx` в `.cpp`  
    **# for i in *.cxx; do mv $i ${i%%.cxx}.cpp; done**           - с помощью встроенных средств bash  
