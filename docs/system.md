## 1 Система

!!! abstract ""
    [Оборудование](#11-информация-об-аппаратном-обеспечении) | [Статистика](#12-загрузка-статистика-и-сообщения) | [Пользователи](#13-пользователи) | [Ограничения](#14-ограничения) | [Уровни выполнения](#15-уровни-выполнения) | [Сброс пароля root](#16-сброс-пароля-root) | [Модули ядра](#17-модули-ядра) | [Компиляция ядра](#18-компиляция-ядра) | [Восстановление grub](#19-восстановление-grub) | [LVM](110-lvm) | [Разное](#111-разное)

!!! example "Информация о работающем ядре и системе"
    **# uname -a**                           - Получить версию ядра (так же выводит и версию BSD)  
    **# lsb_release -a**                     - Полная информация о выпуске любого дистрибутива LSB  
    **# cat /etc/redhat-release**            - Получить версию Red Hat  
    **# cat /etc/SuSE-release**              - Получить версию SuSE  
    **# cat /etc/debian_version**            - Получить версию Debian  

Используйте `/etc/DISTR-release` с DISTR= lsb (Ubuntu), redhat, gentoo, mandrake, sun (Solaris) и т.д. См. также `/etc/issue`.

!!! example ""
    **# uptime**                             - Показать, как долго система работает + загрузку  
    **# hostname**                           - Имя хоста системы  
    **# hostname -i**                        - Отобразить IP-адрес хоста. (Только для Linux)  
    **# man hier**                           - Описание иерархии файловой системы  
    **# last reboot**                        - Показать историю перезагрузок системы  

### 1.1 Информация об аппаратном обеспечении

Обнаруженное ядром оборудование.

!!! example ""
    **# dmesg**                              - Обнаруженное оборудование и сообщения загрузки  
    **# lsdev**                              - Информация об установленном оборудовании  
    **# dd if=/dev/mem bs=1k skip=768 count=256 2&gt;/dev/null | strings -n 8** - Чтение BIOS  

!!! example "Linux"
    **# cat /proc/cpuinfo**                  - Модель процессора  
    **# cat /proc/meminfo**                  - Аппаратная память  
    **# grep MemTotal /proc/meminfo**        - Отобразить физическую память  
    **# watch -n1 'cat /proc/interrupts'**   - Непрерывно отслеживать изменяемые прерывания  
    **# free -m**                            - Использованная и свободная память (-m для МБ)  
    **# cat /proc/devices**                  - Настроенные устройства  
    **# lspci -tv**                          - Показать устройства PCI  
    **# lsusb -tv**                          - Показать устройства USB  
    **# lshal**                              - Показать список всех устройств со свойствами  
    **# dmidecode**                          - Показать информацию о оборудовании DMI/SMBIOS из BIOS  

!!! example "FreeBSD"
    **# sysctl hw.model**                    - Модель процессора  
    **# sysctl hw**                          - Предоставляет много информации об оборудовании  
    **# sysctl hw.ncpu**                     - Количество установленных активных процессоров  
    **# sysctl vm**                          - Использование памяти  
    **# sysctl hw.realmem**                  - Аппаратная память  
    **# sysctl -a | grep mem**               - Настройки и информация о памяти ядра  
    **# sysctl dev**                         - Настроенные устройства  
    **# pciconf -l -cv**                     - Показать устройства PCI  
    **# usbdevs -v**                         - Показать устройства USB  
    **# atacontrol list**                    - Показать устройства ATA  
    **# camcontrol devlist -v**              - Показать устройства SCSI  

### 1.2 Загрузка, статистика и сообщения

Следующие команды полезны для определения того, что происходит в системе.

!!! example ""
    **# top**                                - отображение и обновление процессов с наибольшим использованием ЦП  
    **# mpstat 1**                           - статистика, связанная с процессорами  
    **# vmstat 2**                           - статистика виртуальной памяти  
    **# iostat 2**                           - статистика ввода-вывода (интервалы в 2 секунды)  
    **# systat -vmstat 1**                   - сводка статистики системы BSD (интервалы в 1 секунду)  
    **# systat -tcp 1**                      - соединения TCP BSD (попробуйте также -ip)  
    **# systat -netstat 1**                  - активные сетевые соединения BSD  
    **# systat -ifstat 1**                   - сетевой трафик через активные интерфейсы BSD  
    **# systat -iostat 1**                   - загрузка ЦП и дискового пропускного способности BSD  
    **# ipcs -a**                            - информация о межпроцессных коммуникациях System V  
    **# tail -n 500 /var/log/messages**      - Последние 500 сообщений ядра/syslog  
    **# tail /var/log/warn**                 - Предупреждающие сообщения системы, см. syslog.conf  

### 1.3 Пользователи

Следующие команды полезны для определения того, что происходит в системе.

!!! example ""
    **# id**                                 - Показать активный идентификатор пользователя с логином и группой  
    **# last**                               - Показать последние входы в систему  
    **# who**                                - Показать, кто вошел в систему  
    **# groupadd admin**                     - Добавить группу "admin" и пользователя colin (Linux/Solaris)  
    **# useradd -c "Colin Barschel" -g admin -m colin**  
    **# usermod -a -G <группа> <пользователь>**            - Добавить существующего пользователя в группу (RedHat/Debian)  
    **# groupmod -A <пользователь> <группа>**              - Добавить существующего пользователя в группу (SuSE)  
    **# passwd <пользователь>**                            - Сменить пароль указанному пользователю (в интерактивном режиме)  
    **# echo "пользователь:пароль" | sudo chpasswd**       - Сменить пароль указанному пользователю (в скриптах)  
    **# userdel colin**                      - Удалить пользователя colin (Linux/Solaris)  
    **# adduser joe**                        - FreeBSD: добавить пользователя joe (интерактивно)  
    **# rmuser joe**                         - FreeBSD: удалить пользователя joe (интерактивно)  
    **# pw groupadd admin**                  - Использовать pw на FreeBSD  
    **# pw groupmod admin -m newmember**     - Добавить нового участника в группу  
    **# pw useradd colin -c "Colin Barschel" -g admin -m -s /bin/tcsh**  
    **# pw userdel colin; pw groupdel admin**  

Зашифрованные пароли хранятся в /etc/shadow для Linux и Solaris, и в /etc/master.passwd для FreeBSD. Если master.passwd изменяется вручную (например, для удаления пароля), выполните команду `# pwd_mkdb -p master.passwd` для перестроения базы данных.
Чтобы временно запретить вход в систему для всех пользователей, кроме root, используйте nologin. Сообщение в nologin будет отображаться (это может не работать с предварительно распределенными ключами ssh).

!!! example ""
    **# echo "Sorry no login now" > /etc/nologin**       - (Linux)  
    **# echo "Sorry no login now" > /var/run/nologin**   - (FreeBSD)  

### 1.4 Ограничения

Некоторым приложениям требуются более высокие ограничения на открытые файлы и сокеты (например, прокси-серверы, веб-серверы, базы данных). По умолчанию ограничения обычно слишком низкие.

#### Linux

*Для каждой оболочки/скрипта*
Ограничения оболочки управляются с помощью ulimit. Состояние можно проверить с помощью `ulimit -a`. Например, чтобы изменить ограничение на количество открытых файлов с 1024 до 10240, выполните:

!!! example ""
    **# ulimit -n 10240**                    - Это действительно только в пределах оболочки  

Команду `ulimit` можно использовать в скрипте для изменения ограничений только для этого скрипта.

*Для каждого пользователя/процесса*
Входные пользователи и приложения могут быть настроены в файле `/etc/security/limits.conf`. Например:

!!! example ""
    **# cat /etc/security/limits.conf**  
    **\*   hard    nproc   250**             - Ограничение на количество процессов пользователя  
    **asterisk hard nofile 409600**          - Ограничение на количество открытых файлов приложения  

*Для всей системы*
Ограничения ядра устанавливаются с помощью `sysctl`. Постоянные ограничения устанавливаются в файле `/etc/sysctl.conf`.

!!! example ""
    **# sysctl -a**                          - Просмотр всех системных ограничений  
    **# sysctl fs.file-max**                 - Просмотр максимального ограничения на количество открытых файлов  
    **# sysctl fs.file-max=102400**          - Изменение максимального ограничения на количество открытых файлов  
    **# echo "1024 50000" > /proc/sys/net/ipv4/ip_local_port_range**  - диапазон портов  
    **# cat /etc/sysctl.conf**  
    *fs.file-max=102400*                     - Постоянная запись в sysctl.conf  
    **# cat /proc/sys/fs/file-nr**           - Сколько файловых дескрипторов используется  

#### FreeBSD

*На уровне оболочки/скрипта*
Используйте команду `limits` в оболочках csh или tcsh, или, как в Linux, используйте `ulimit` в оболочках sh или bash.

*На уровне пользователя/процесса*
По умолчанию ограничения при входе в систему устанавливаются в файле `/etc/login.conf`. Значение "неограничено" все равно ограничено максимальным значением системы.

*На уровне всей системы*
Ограничения ядра также устанавливаются с помощью `sysctl`. Постоянные ограничения устанавливаются в файлах `/etc/sysctl`.conf или `/boot/loader.conf`. Синтаксис такой же, как в Linux, но ключи отличаются.

!!! example ""
    **# sysctl -a**                          - Просмотр всех системных ограничений  
    **# sysctl kern.maxfiles=XXXX**          - Максимальное количество файловых дескрипторов  
    *kern.ipc.nmbclusters=32768*             - Постоянная запись в /etc/sysctl.conf  
    *kern.maxfiles=65536*                    - Типичные значения для Squid  
    *kern.maxfilesperproc=32768*  
    *kern.ipc.somaxconn=8192*                - TCP ... 1024-5000  
    **# sysctl kern.openfiles**              - Сколько дескрипторов файлов используется  
    **# sysctl kern.ipc.numopensockets**     - Сколько открытых сокетов используется  
    **# sysctl net.inet.ip.portrange.last=50000** - По умолчанию 1024-5000  
    **# netstat -m**                         - Статистика буферов памяти сети  

#### Solaris

Следующие значения в файле `/etc/system` увеличат максимальное количество файловых дескрипторов для одного процесса:

!!! example ""
    *set rlim_fd_max = 4096*               - Жесткий лимит на количество файловых дескрипторов для одного процесса  
    *set rlim_fd_cur = 1024*               - Мягкий лимит на количество файловых дескрипторов для одного процесса  

### 1.5 Уровни выполнения

#### Linux

##### SystemV

После загрузки ядро запускает `init`, который затем запускает rc, который запускает все скрипты, принадлежащие к уровню выполнения. Скрипты хранятся в `/etc/init.d` и связаны с `/etc/rc.d/rcN.d`, где N - номер уровня выполнения.

Уровень выполнения по умолчанию настраивается в файле `/etc/inittab`. Обычно это 3 или 5:

!!! example ""
    **# grep default: /etc/inittab**  
    id:3:initdefault:     

Фактический уровень выполнения может быть изменен с помощью команды `init`. Например, чтобы перейти с уровня выполнения 3 на уровень выполнения 5, выполните:

!!! example ""
    **# init 5**     - Вход в уровень выполнения 5

!!! info ""
    0   Выключение и остановка  
    1   Однопользовательский режим (также S)  
    2   Многопользовательский режим без сети  
    3   Multi-user with network  
    5   Multi-user with X  
    6   Reboot  

Используйте команду `chkconfig` для настройки программ, которые будут запускаться при загрузке в определенном уровне выполнения (runlevel).

!!! example ""
    **# chkconfig --list**                   - Список всех скриптов инициализации  
    **# chkconfig --list sshd**              - Состояние службы sshd  
    **# chkconfig sshd --level 35 on**       - Конфигурация sshd для уровней 3 и 5  
    **# chkconfig sshd off**                 - Отключение sshd для всех уровней запуска  

Debian и дистрибутивы на основе Debian, такие как Ubuntu или Knoppix, используют команду `update-rc.d` для управления скриптами запуска в различных уровнях выполнения. По умолчанию служба запускается в уровнях 2, 3, 4 и 5, а останавливается в уровнях 0, 1 и 6.

!!! example ""
    **# update-rc.d sshd defaults**          - Активация sshd с настройками по умолчанию  
    **# update-rc.d sshd start 20 2 3 4 5 . stop 20 0 1 6 .**  - С явными аргументами  
    **# update-rc.d -f sshd remove**         - Отключение sshd для всех уровней запуска  
    **# shutdown -h now (или # poweroff)**   - Выключение и остановка системы  

##### Systemd

*systemd* — набор базовых компонентов Linux-системы. Представляет собой менеджер системы и служб, который выполняется как процесс с PID 1 и запускает остальную часть системы. systemd обеспечивает возможности агрессивной параллелизации, сокетную и D-Bus активацию для запуска служб, запуск демонов по запросу, отслеживание процессов с помощью контрольных групп Linux, обслуживание точек (авто)монтирования, а также предлагает развитую транзакционную логику управления службами на основе зависимостей. systemd поддерживает сценарии инициализации SysV и LSB и работает как замена *sysvinit*. Большинство систем Linux отказались от файла `/etc/inittab` в пользу systemd targets. Главная команда для работы с systemd — systemctl. Она позволяет (среди прочего) отлеживать состояние системы и управлять системой и службами.

Systemd использует юнит типа цель (target) для группировки юнитов по зависимостям и в качестве стандартизированных точек синхронизации. Они выполняют ту же задачу, что и уровни запуска, но действуют немного по-другому. Каждая цель имеет имя, а не номер, и предназначена для конкретных задач; несколько целей могут быть активны одновременно. Некоторые цели реализованы путём наследования служб из других целей с добавлением собственных.

!!! example ""
    **$ systemctl get-default**                  - Узнать текущую цель  
    **# systemctl isolate graphical.target**     - Изменение текущей цели командой  
    **# systemctl set-default graphical.target** - Установка новой цели загрузки по умолчанию  

Соответствие уровней SysV целям systemd:


| Уровнень запуска SysV | Цель systemd                                          | Примечания                                                                                                                          |
| --------------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| 0                     | runlevel0.target, poweroff.target                     | Выключение системы                                                                                                                  |
| 1, s, single          | runlevel1.target, rescue.target                       | Однопользовательский уровень запуска                                                                                                |
| 2, 4                  | runlevel2.target, runlevel4.target, multi-user.target | Уровни запуска, определенные пользователем/специфичные для узла. По умолчанию соответствует уровню запуска 3                        |
| 3                     | runlevel3.target, multi-user.target                   | Многопользовательский режим без графики. Пользователи, как правило, входят в систему при помощи множества консолей или через сеть   |
| 5                     | runlevel5.target, graphical.target                    | Многопользовательский режим с графикой. Обычно эквивалентен запуску всех служб на уровне 3 и графического менеджера входа в систему |
| 6                     | runlevel6.target, reboot.target                       | Перезагрузка                                                                                                                        |
| emergency             | emergency.target                                      | Аварийная оболочка                                                                                                                  |

#### FreeBSD

Подход к загрузке BSD отличается от SysV: здесь нет уровней выполнения. Конфигурация конечного состояния загрузки (однопользовательский режим с X или без него) выполняется в файле `/etc/ttys`. Все скрипты операционной системы располагаются в каталоге `/etc/rc.d/`, а сторонних приложений - в `/usr/local/etc/rc.d/`. Включение службы настраивается в файлах `/etc/rc.conf` и `/etc/rc.conf.local`. Поведение по умолчанию настраивается в файле `/etc/defaults/rc.conf`. Скрипты поддерживают команды `start|stop|status`.

!!! example ""
    **# /etc/rc.d/sshd status**  
    *sshd работает с PID 552.*  
    **# shutdown now**                       - Переход в однопользовательский режим  
    **# exit**                               - Возврат в многопользовательский режим  
    **# shutdown -p now**                    - Выключение и остановка системы  
    **# shutdown -r now**                    - Перезагрузка  

Также можно использовать процесс init для перехода в одно из следующих состояний:

!!! info ""
    0 &nbsp; &nbsp; &nbsp; Остановка и выключение питания (сигнал USR2)  
    1 &nbsp; &nbsp; &nbsp; Переход в однопользовательский режим (сигнал TERM)  
    6 &nbsp; &nbsp; &nbsp; Перезагрузка машины (сигнал INT)  
    c &nbsp; &nbsp; &nbsp; Запрет дальнейшего входа (сигнал TSTP)  
    q &nbsp; &nbsp; &nbsp; Пересканирование файла ttys(5) (сигнал HUP)  

#### Windows

Запуск и остановка службы возможны с использованием имени службы или "описания службы" (которое отображается в панели управления службами) следующим образом:

!!! example ""
    **net stop WSearch**                     # остановить службу поиска  
    **net start WSearch**                    # запустить службу поиска  
    **net stop "Windows Search"**            # остановить службу поиска Windows  
    **net start "Windows Search"**           # запустить службу поиска Windows  

### 1.6 Сброс пароля root

#### Linux

##### Метод 1

**В системе RHEL/CentOS до версии 7:**

* При загрузке загрузчика (lilo или grub) введите следующую опцию загрузки: `init=/bin/sh`

* Ядро примонтирует корневое раздел и запустит оболочку Bourne вместо rc и затем уровня выполнения. Используйте команду passwd для изменения пароля, а затем перезагрузитесь. Забудьте о режиме одного пользователя, так как для этого вам понадобится пароль.

* Если после загрузки корневой раздел смонтирован только для чтения, перемонтируйте его для записи:

!!! example ""
    **# mount -o remount,rw /**  
    **# passwd**                             - или удалите пароль root (/etc/shadow)  
    **# sync; mount -o remount,ro /**        - синхронизируйте перед повторным примонтирование только для чтения  
    **# reboot**  

**В системе RHEL/CentOS версии 7 или более поздней:**

* Как только загрузчик откроется экран выбора, быстро нажмите стрелки вверх и вниз, чтобы приостановить обратный отсчет.
* Выберите ядро, с которым вы хотите загрузиться, и нажмите `e`: вы попадете на экран, где сможете редактировать сценарий загрузчика grub.

!!! note ""
    a. Для RHEL/CentOS 7 строка начинается с «linux16».  
    b. Для RHEL/Centos 8x и Fedora строка начинается с «linux».  

* Добавьте «rd.break» в конце строки  (здесь вы можете сделать и другие вещи, но на данный момент это все, что вам нужно).
* Теперь нажмите ++ctrl+x++, чтобы запустить отредактированный скрипт загрузчика.
* Вы загрузитесь и увидите приглашение восстановления, которое выглядит следующим образом: `switch_root:/#`.
* Перемонтируйте корневой раздел в режиме чтения и записи, чтобы можно было выполнять команды. Введите следующее: `mount -o remount rw /sysroot`.
* Теперь введите `chroot/sysroot` и нажмите ++enter++. Вы перейдете в каталог `sysroot (/)`.
* Теперь вы можете просто изменить пароль для *root* с помощью команды `passwd`.
* Далее, перед перезагрузкой, вам нужно будет убедиться, что SELinux разрешает изменение файлов. В командной строке введите: `touch /.autorelabel`. Это сигнализирует SELinux при следующей перезагрузке об изменении файловой системы (измененный пароль) и позволяет загрузить изменения.
* Введите `exit`, чтобы выйти из среды chroot, и введите `reboot`.

##### Метод 2

* Запустите систему и, когда отобразится информация о BIOS, выберите опцию меню загрузки и выберите загрузку с установочного диска.
* Выберите **Troubleshooting**.
* Выберите **Rescue a Red Hat Enterprise Linux System**.
* Выберите **Continue** набрав **1** в ответ на диалоговое окно ниже, а затем нажмите клавишу ++enter++.
* Получив приглашение ниже, нажмите клавишу ++enter++. Пожалуйста, нажмите ++enter++, чтобы получить оболочку.
* Теперь вы попали в оболочку восстановления, запустите команду `# chroot /mnt/sysroot`, чтобы изменить корень файловой системы на образ вашей системы.
* Запустите команду `# passwd root`, чтобы изменить корневой пароль системы.
* Удалите файл автоматической перемаркировки, чтобы предотвратить трудоемкую перемаркировку диска SELinux: `# rm -f /.autorelabel`.
* Введите команду `# exit`, чтобы выйти из среды chroot.
* Введите команду `# exit` еще раз, чтобы возобновить инициализацию и завершить загрузку системы.

#### FreeBSD

В FreeBSD загрузитесь в однопользовательский режим, перемонтируйте / в режиме записи и используйте passwd. Вы можете выбрать однопользовательский режим в меню загрузки (опция 4), которое отображается в течение 10 секунд после запуска. Однопользовательский режим предоставит вам корневую оболочку на разделе /.

!!! example ""
    **# mount -u /; mount -a**               - примонтирует / в режиме записи  
    **# passwd**  
    **# reboot**  

#### Unixes, FreeBSD и Linux

Другие Unix-подобные системы могут не позволять вам использовать простой трюк с init. Решение заключается в примонтировании корневого раздела из другой ОС (например, с помощью спасательного CD) и изменении пароля на диске.

Загрузите спасательный CD или установочный CD в режиме восстановления, который предоставит вам оболочку.
Найдите корневой раздел с помощью `fdisk`, например `fdisk /dev/sda`.

Примонтируйте его и используйте `chroot`:

!!! example ""
    **# mount -o rw /dev/ad4s3a /mnt**  
    **# chroot /mnt**                        - chroot в /mnt  
    **# passwd**  
    **# reboot**  

### 1.7 Модули ядра

!!! example "Linux"
    **# lsmod**                             - Показать все загруженные модули в ядре  
    **# modprobe isdn**                     - Загрузить модуль (здесь isdn)  

!!! example "FreeBSD"
    **# kldstat**                            - Показать все загруженные модули в ядре  
    **# kldload crypto**                     - Загрузить модуль (здесь crypto)  

### 1.8 Компиляция ядра

#### Linux

!!! example ""
    **# cd /usr/src/linux**  
    **# make mrproper**                      - Очистить все, включая файлы конфигурации  
    **# make oldconfig**                     - Повторное использование старого `.config`, если существует  
    **# make menuconfig**                    - или `xconfig` (Qt) или `gconfig` (GTK)  
    **# make**                               - Создать сжатый образ ядра  
    **# make modules**                       - Скомпилировать модули  
    **# make modules_install**               - Установить модули  
    **# make install**                       - Установить ядро  
    **# reboot**

#### FreeBSD
При необходимости обновите исходное дерево (в `/usr/src`) с помощью csup (начиная с FreeBSD 6.2 или более поздней версии):

!!! example ""
    **# csup \<supfile\>**

!!! example "Я использую следующий supfile:"
    *default host=cvsup5.FreeBSD.org  - www.freebsd.org/handbook/cvsup.html#CVSUP-MIRRORS  
    *default prefix=/usr  
    *default base=/var/db  
    *default release=cvs delete tag=RELENG_7  
    src-all  

Для изменения и перестройки ядра скопируйте общий файл конфигурации с новым именем и отредактируйте его по необходимости (вы также можете редактировать файл GENERIC напрямую). Чтобы возобновить компиляцию после прерывания, добавьте опцию `NO_CLEAN=YES` к команде make, чтобы избежать очистки уже созданных объектов.

!!! example ""
    **# cd /usr/src/sys/i386/conf/**  
    **# cp GENERIC MYKERNEL**  
    **# cd /usr/src**  
    **# make buildkernel KERNCONF=MYKERNEL**  
    **# make installkernel KERNCONF=MYKERNEL**  

!!! example "Для перестройки полной операционной системы:"
    **# make buildworld**                    - Построить полную операционную систему, но не ядро  
    **# make buildkernel**                   - Используйте KERNCONF, как указано выше, если применимо  
    **# make installkernel**  
    **# reboot**  
    **# mergemaster -p**                     - Сравнивает только файлы, известные как существенные  
    **# make installworld**  
    **# mergemaster -i -U**                  - Обновить все конфигурационные файлы и другие файлы  
    **# reboot**  

!!! example "Для небольших изменений в исходном коде вы можете использовать *NO_CLEAN=yes*, чтобы избежать перестройки всего дерева."
    **# make buildworld NO_CLEAN=yes**       - Не удалять старые объекты  
    **# make buildkernel KERNCONF=MYKERNEL NO_CLEAN=yes**  

### 1.9 Восстановление grub

Вы испортили grub? Загрузитесь с помощью Live CD, [найдите раздел Linux в /dev и используйте fdisk для поиска раздела Linux], примонтируйте раздел Linux, добавьте /proc и /dev, а затем выполните команду `grub-install /dev/xyz`. Предположим, что Linux находится на разделе `/dev/sda6`:

!!! example ""
    **# mount /dev/sda6 /mnt**                - монтирование раздела Linux на /mnt  
    **# mount --bind /proc /mnt/proc**        - монтирование подсистемы proc в /mnt  
    **# mount --bind /dev /mnt/dev**          - монтирование устройств в /mnt  
    **# chroot /mnt**                         - изменение корневой директории на раздел Linux  
    **# grub-install /dev/sda**               - переустановка grub с предыдущими настройками  

### 1.10 LVM

**LVM** (*Logical Volume Manager*), менеджер логических томов - это система управления дисковым пространством, абстрагирующаяся от физических устройств.

Обозначения и понятия:

* **PV, Physical volume, физический том.** - Обычно это раздел на диске или весь диск. В том числе, устройства программного и аппаратного RAID (которые уже могут включать в себя несколько физических дисков). Физические тома входят в состав группы томов.

* **VG, Volume group, группа томов.** - Это самый верхний уровень абстрактной модели, используемой системой LVM. С одной стороны группа томов состоит из физических томов, с другой -- из логических и представляет собой единую административную единицу.

* **LV, Logical volume, логический том.** - Раздел группы томов, эквивалентен разделу диска в не-LVM системе. Представляет собой блочное устройство и, как следствие, может содержать файловую систему.

* **PE, Physical extent, физический экстент.** - Каждый физический том делиться на порции данных, называющиеся физическими экстентами. Их размеры те же, что и у логических экстентов.

* **LE, Logical extent, логический экстент.** - Каждый логический том делится на порции данных, называющиеся логическими экстентами. Размер логических экстентов не меняется в пределах группы томов.

**Работа с LVM**

Давайте теперь рассмотрим задачи, стоящие перед администратором LVM системы. Помните, что для работы с системой LVM ее нужно инициализировать командами:

!!! example ""
    **# vgscan**
    **# vgchange -ay**

Первая команда сканирует диски на предмет наличия групп томов, вторая активирует все найденные группы томов. Аналогично для завершения всех работ, связанных с LVM, нужно выполнить деактивацию групп:

!!! example ""
    **# vgchange -an**

Первые две строки нужно будет поместить в скрипты автозагрузки (если их там нет), а последнюю можно дописать в скрипт `shutdown`.

#### Инициализация дисков и разделов

Перед использованием диска или раздела в качестве физического тома необходимо его инициализировать:

* Для целого диска:

!!! example "Эта команда создает в начале диска дескриптор группы томов"
    **# pvcreate /dev/sdb**

Если вы получили ошибку инициализации диска с таблицей разделов - проверьте, что работаете именно с нужным диском, и когда полностью будете уверены в том, что делаете, выполните следующие команды

!!! example "Эти команды уничтожат таблицу разделов на целевом диске"
    **# dd if=/dev/zero of=/dev/diskname bs=1k count=1**
    **# blockdev --rereadpt /dev/diskname**

* Для разделов:

Установите программой fdisk тип раздела в 0x8e.

!!! example "Команда создаст в начале раздела */dev/sdb1* дескриптор группы томов."
    **# pvcreate /dev/sdb1**

#### Создание группы томов

Для создания группы томов используется команда `vgcreate`

!!! example ""
    **# vgcreate vg00  /dev/sda1 /dev/sdb1**

!!! note "Замечание"
    Если вы используете devfs важно указывать полное имя в devfs, а не ссылку в каталоге `/dev`. 

!!! example "Таким образом приведенная команда должна выглядеть в системе с devfs так:"
    **# vgcreate vg00  /dev/ide/host0/bus0/target0/lun0/part1 /dev/ide/host0/bus0/target1/lun0/part1**

Кроме того, вы можете задать размер экстента при помощи ключа `-s`, если значение по умолчанию в 32Мб вас не устраивает. Можно, также, указать ограничения возможного количества физических и логических томов.

#### Активация группы томов

После перезагрузки системы или выполнения команды `vgchange -an`, ваши группы томов и логические тома находятся в неактивном состоянии. Для их активации необходимо выполнить команду

!!! example ""
    **# vgchange -a y vg00**

#### Удаление группы томов

Убедитесь, что группа томов не содержит логических томов. Как это сделать, показано в следующих разделах.

!!! example "Деактивируйте группу томов:"
    **# vgchange -a n vg00**

!!! example "Теперь можно удалить группу томов командой:"
    **# vgremove vg00**

#### Добавление физических томов в группу томов

Для добавления предварительно инициализированного физического тома в существующую группу томов используется команда `vgextend`:

!!! example "новый физический том /dev/sdc1"
    **# vgextend vg00 /dev/sdc1**

#### Удаление физических томов из группы томов

Убедитесь, что физический том не используется никакими логическими томами. Для этого используйте команду `pvdisplay`:

!!! example ""
    **# pvdisplay /dev/sda1**
    ```console
    --- Physical volume ---
       PV Name            /dev/sda1
       VG Name            vg00
       PV Size            1.95 GB / NOT usable 4 MB [LVM: 122 KB]
       PV#                1
       PV Status          available
       Allocatable        yes (but full)
       Cur LV             1
       PE Size (KByte)    4096
       Total PE           499
       Free PE            0
       Allocated PE       499
       PV UUID            Sd44tK-9IRw-SrMC-MOkn-76iP-iftz-OVSen7
    ```

Если же физический том используется, вам нужно будет перенести данные на другой физический том. Эта процедура будет описана в следующих разделах.

После этого можно использовать `vgreduce` для удаления физических томов:

!!! example ""
    **# vgreduce vg00 /dev/sda1**

#### Создание логического тома

Для того, чтобы создать логический том `lv00`, размером 1500Мб, выполните команду:

!!! example ""
    **# lvcreate -L1500 -nlv00 vg00**

Для создания логического тома размером в 100 логических экстентов с расслоением по двум физическим томам и размером блока данных 4 KB:

!!! example ""
    **# lvcreate -i2 -I4 -l100 -nlv01 vg00**

Если вы хотите создать логический том, полностью занимающий группу томов, выполните команду `vgdisplay`, чтобы узнать полные размер группы томов, после чего используйте команду `lvcreate`.

!!! example ""
    **# vgdisplay vg00 | grep "Total PE"**  
    Total PE        10230  
    **# lvcreate -l 10230 vg00 -n lv02**  

Эти команды создают логический том *testvg*, полностью заполняющий группу томов.

#### Удаление логических томов

Логический том должен быть размонтирован перед удалением:

!!! example ""
    **# umount /dev/vg00/home**  
    **# lvremove /dev/vg00/home**  
    ```console
    lvremove -- do you really want to remove "/dev/vg00/home"? [y/n]:    y
    lvremove -- doing automatic backup of volume group "vg00"
    lvremove -- logical volume "/dev/vg00/home" successfully removed
    ```

#### Увеличение логических томов

Для увеличения логического тома вам нужно просто указать команде lvextend до какого размера вы хотите увеличить том:

!!! example ""
    **# lvextend -L12G /dev/vg00/home**
    ```console
    lvextend -- extending logical volume "/dev/vg00/home" to 12 GB
    lvextend -- doing automatic backup of volume group "vg00"
    lvextend -- logical volume "/dev/vg00/home" successfully extended
    ```

В результате `/dev/vg00/home` увеличится до 12Гбайт.

!!! example ""
    **# lvextend -L+1G /dev/vg00/home**
    ```console
    lvextend -- extending logical volume "/dev/vg00/home" to 13 GB
    lvextend -- doing automatic backup of volume group "vg00"
    lvextend -- logical volume "/dev/vg00/home" successfully extended
    ```

Эта команда увеличивает размер логического тома на 1Гб.

!!! attention "Внимание"
    После того как вы увеличили логический том, необходимо соответственно увеличить размер файловой системы. Как это сделать зависит от типа используемой файловой системы.

#### Уменьшение размера логического тома

Логические тома могут быть уменьшены в размере, точно также как и увеличены. Однако очень важно помнить, что нужно в первую очередь уменьшить размер файловой системы, и только после этого уменьшать размер логического тома. Если вы нарушите последовательность, вы можете потерять данные.

!!! attention "Внимание"
    Уменьшить размер файловой системы XFS нельзя.

#### Перенос данных с физического тома

Для того, чтобы можно было удалить физический том из группы томов, необходимо освободить все занятые на нем физические экстенты. Это делается путем перераспределения занятых физических экстентов на другие физические тома. Следовательно, в группе томов должно быть достаточно свободных физических экстентов. Описание операции удаления физического тома приведено в разделе примеров.

#### Перенос группы томов на другую систему

Физический перенос группы томов на другую систему организовывается при помощи команд `vgexport` и `vgimport`.

Сперва необходимо размонтировать все логические тома группы томов и деактивировать группу:

!!! example ""
    **# unmount /mnt/design/users**  
    **# vgchange -an design**  
    ```console
    vgchange -- volume group "design" successfully deactivated
    ```

После этого экспортируем группу томов. Процедура экспорта запрещает доступ к группе на данной системе и готовит ее к удалению:

!!! example ""
    **# vgexport design**
    ```console
    vgexport -- volume group "design" sucessfully exported
    ```

Теперь можно выключить машину, отсоединить диски, составляющие группу томов и подключить их к новой системе. Остается импортировать группу томов на новой машине и смонтировать логические тома:

!!! example ""
    **# pvscan**
    ```console
    pvscan -- reading all physical volumes (this may take a while...)
    pvscan -- inactive PV "/dev/sdb1"  is in EXPORTED VG "design" [996 MB / 996 MB free]
    pvscan -- inactive PV "/dev/sdb2"  is in EXPORTED VG "design" [996 MB / 244 MB free]
    pvscan -- total: 2 [1.95 GB] / in use: 2 [1.95 GB] / in no VG: 0 [0]
    ```
    **# vgimport design /dev/sdb1 /dev/sdb2**
    ```console
    vgimport -- doing automatic backup of volume group "design"
    vgimport -- volume group "design" successfully imported and activated
    ```
    **# mkdir -p /mnt/design/users**  
    **# mount /dev/design/users /mnt/design/users**  

Группа томов готова к использованию на новой системе.

### 1.11 Разное

Отключение виртуальной памяти в macOS (для повторного включения выполните аналогичные команды). Это ускорит систему, но немного рискованно.

!!! example ""
    **# sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.dynamic_pager.plist**  
    **# sleep 3600; pmset sleepnow**                            - перейти в режим ожидания через один час (macOS)  
    **# defaults write -g com.apple.mouse.scaling -float 8**    - ускорение мыши в macOS (используйте -1 для обратного эффекта)  
