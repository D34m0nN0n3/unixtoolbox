## 2 Процессы

!!! abstract ""
    [Список](#21-список-и-pid-ы) | [Приоритет](#22-приоритет) | [Фон/Передний план](#23-фонпередний-план) | [Top](#24-top) | [Сигналы/Завершение](#25-сигналызавершение)  

### 2.1 Список и PID-ы

Каждый процесс имеет уникальный номер - PID. Процессы создают иерархию в виде дерева. Самым "главным" предком, то есть процессом, стоящим на вершине этого дерева, является процесс init (PID=1). Список всех выполняемых процессов можно получить с помощью команды `ps`.

!!! example ""
    **# ps -auxefw**                         - Расширенный список всех запущенных процессов

Однако более типичное использование происходит с использованием конвейера или с помощью pgrep (для установки `proctools` из MacPorts в ОС X):

!!! example ""
    **# ps axww | grep cron**
    *  586  ??  Is     0:01.48 /usr/sbin/cron -s*  
    **# ps axjf**                            - Все процессы в формате дерева (Linux)  
    **# ps aux | grep 'ss[h]'**              - Найти все PID процессов ssh без PID grep  
    **# pgrep -l sshd**                      - Найти PID процессов по (части) имени  
    **# echo $$**                            - PID вашей оболочки  
    **# fuser -va 22/tcp**                   - Список процессов, использующих порт 22 (Linux)  
    **# pmap PID**                           - Карта памяти процесса (поиск утечек памяти) (Linux)  
    **# fuser -va /home**                    - Список процессов, обращающихся к разделу /home  
    **# strace df**                          - Отслеживание системных вызовов и сигналов  
    **# truss df**                           - то же самое на FreeBSD/Solaris/Unixware  

!!! info "В колонке **STAT** может содержать следующие значения:"
    1. R - (*RUNNING & RUNNABLE*) процесс выполняется или готов к выполнению (состояние готовности)  
    2. D - (*UNINTERRUPTABLE_SLEEP*) процесс в "беспробудном сне" - ожидает дискового ввода/вывода  
    3. T - (*STOPPED*) процесс остановлен (stopped) или трассируется отладчиком  
    4. S - (*INTERRRUPTABLE_SLEEP*) процесс в состоянии ожидания (sleeping)  
    5. Z - (*ZOMBIE*) процесс-зобми  
    6. < - процесс с отрицательным значением nice  
    7. N - процесс с положительным значением nice (о команде nice мы поговорим позже)  

!!! note "RUNNING & RUNNABLE"
    Хотя `run` и `runable` обычно объединяют в одно целое, между ними есть небольшие различия. В большинстве случаев это различие не имеет значения, поскольку оно указывает на то, что процесс либо поставлен в очередь на выполнение, либо находится в процессе выполнения. Разница между запущенным и работоспособным заключается в том, что работающий процесс готов и настроен для запуска, но по какой-то причине ЦП не готов к его планированию. Поэтому он поставлен в очередь на запуск. Это может произойти, когда запланировано слишком много процессов, а процессорного времени недостаточно.

!!! note "UNINTERRUPTABLE_SLEEP"
    Обычно в этом состоянии прерывание может вызвать некоторые серьезные проблемы. Процесс в этом состоянии встречается редко, но если это так, то обычно это происходит из-за системного вызова. Отличным примером является команда `mkdir`. Он выполняет системный вызов ядра и во время этого переходит в это состояние. Для локальных дисков это происходит мгновенно, за исключением крайних случаев. При использовании сетевой файловой системы, такой как NFS, возможно, что в этом состоянии она может зависать на неопределенный срок.

!!! note "STOPPED"
    Многие приложения и консольные инструменты/приложения позволяют использовать ++ctrl+Z++ для приостановки процессов. В этом состоянии процесс приостановлен и не отвечает. Пример того, когда у вас может быть процесс в этом состоянии, — это когда у вас есть приложение переднего плана, запрашивающее пользовательский ввод, но вы еще не готовы его вводить. Вы можете использовать ++ctrl+Z++ и перейти к чему-то другому. Когда вы будете готовы вернуться к нему, вы можете запустить команду `fg`, чтобы вернуть его.

!!! note "INTERRRUPTABLE_SLEEP"
    В ходе выполнения процесса он достигнет точки ожидания данных. Это может быть в форме ввода с терминала, например, запроса ввода данных у пользователя. В других случаях процессом может быть веб-сервер, который простаивает в ожидании запроса.  
    Пока оно ожидает этого, хорошо написанное приложение переходит в состояние INTERRUPTABLE_SLEEP. В этом состоянии процесс можно легко завершить без проблем. Переход в это состояние процесса во время ожидания ввода позволяет процессу отойти на второй план и дать другим процессам процессорное время.

!!! note "ZOMBIE"
    Процессы в состоянии ZOMBIE могут показаться странными. Проще говоря, это промежуточное состояние после завершения процесса, но до того, как родительский процесс удалит его из таблицы процессов. Когда процесс завершается, родительский процесс несет ответственность за «пожинать плоды» дочернего процесса и очищать таблицу процессов.  
    Как правило, вы сталкиваетесь с процессами-зомби только в том случае, если родительский процесс не выполнил эту очистку и у вас есть процесс, который задерживается. Название, вероятно, происходит от аналогии с тем, что зомби не мертвы, они нежить.

### 2.2 Приоритет

Измените приоритет запущенного процесса с помощью команды renice. Отрицательные числа имеют более высокий приоритет, наименьшее значение - `-20`, а `nice` имеет положительное значение.

!!! example ""
    **# renice -5 586**                      - Более сильный приоритет  
    *586: старый приоритет 0, новый приоритет -5*  

Запустите процесс с определенным приоритетом с помощью команды `nice`. Положительное значение - "nice" или слабый приоритет планирования, отрицательное значение - сильный приоритет. Убедитесь, что вы знаете, используется ли `/usr/bin/nice` или встроенная оболочка (проверьте с помощью # `which nice`).

!!! example ""
    **# nice -n -5 top**                     - Более сильный приоритет (`/usr/bin/nice`)  
    **# nice -n 5 top**                      - Более слабый приоритет (`/usr/bin/nice`)  
    **# nice +5 top**                        - Встроенная команда `nice` в `tcsh` (то же самое!)  

В то время как `nice` изменяет планировщик ЦП, другая полезная команда `ionice` позволяет планировать ввод-вывод на диске. Это очень полезно для интенсивных приложений ввода-вывода (например, компиляции). Вы можете выбрать класс (простой - наилучший результат - реальное время), страница руководства короткая и хорошо объяснена.

!!! example ""
    **# ionice c3 -p123**                    - установить класс простой для 'PID 123' (только Linux)  
    **# ionice -c2 -n0 firefox**             - Запустить Firefox с наилучшими усилиями и высоким приоритетом  
    **# ionice -c3 -p$$**                    - Установить текущую оболочку с низким приоритетом  

Последняя команда очень полезна для компиляции (или отладки) большого проекта. Каждая команда, запущенная из этой оболочки, будет иметь более низкий приоритет. $$ - это PID вашей оболочки (попробуйте `echo $$`).
FreeBSD использует `idprio/rtprio` (0 = максимальный приоритет, 31 = наиболее свободный):

!!! example ""
    **# idprio 31 make**                     - компилировать с наименьшим приоритетом  
    **# idprio 31 -1234**                    - установить 'PID 1234' с наименьшим приоритетом  
    **# idprio -t -1234**                    - '-t' удаляет любой реальный приоритет/приоритет простоя  

### 2.3 Фон/Передний план

При запуске из оболочки процессы могут быть переведены в фоновый режим и вернуться в передний план с помощью ++ctrl+z++ `(^Z)`, bg и fg. Список процессов можно получить с помощью команды jobs. При необходимости отсоединитесь от терминала с помощью disown.

!!! example "Пример 1"
    **# ping example.com &gt; ping.log**  
    *^Z*                                     - ping приостановлен (остановлен) с помощью ++ctrl+z++  
    **# bg**                                 - перевести в фоновый режим и продолжить выполнение  
    **# jobs -l**                            - Список процессов в фоновом режиме  
    [1]  - 36232 Running                       ping example.com &gt; ping.log  
    [2]  + 36233 Suspended (tty output)        top  
    **# fg %2**                              - Вернуть процесс 2 в передний план  

!!! example "Пример 2"
    **# make**                               - запустить длительную компиляцию, но нужно покинуть терминал  
    *^Z*                                     - приостановлен (остановлен) с помощью ++ctrl+z++  
    **# bg**                                 - перевести в фоновый режим и продолжить выполнение  
    **# disown -h %1**                       - отсоединить процесс от терминала, не будет завершен при выходе  

Нет прямого способа повторно присоединить процесс к новому терминалу, попробуйте `reptyr` (Linux).

Используйте nohup, чтобы запустить процесс, который должен продолжать работать при закрытии оболочки (устойчив к обрывам соединения).

!!! example ""
    **# nohup ping -i 60 &gt; ping.log &amp;**

### 2.4 Top

Программа top отображает информацию о запущенных процессах. См. также программу `hto`p с htop.sourceforge.net (более мощная версия `top`), которая работает в Linux и FreeBSD (`ports/sysutils/htop/`). Во время работы top нажмите клавишу ++h++ для получения справочного обзора. Полезные клавиши:

!!! example ""
    ++u++ *[имя пользователя]* Для отображения только процессов, принадлежащих пользователю. Используйте + или пробел, чтобы увидеть всех пользователей.  
    ++k++ *[pid]* Завершить процесс с указанным `pid`.  
    ++1++ Для отображения статистики всех процессоров (только Linux).  
    ++shift+r++ Переключение нормальной/обратной сортировки.  

### 2.5 Сигналы/Завершение

Завершите или отправьте сигнал с помощью команды `kill` или `killall`.

!!! example ""
    **# ping -i 60 example.com &gt; ping.log &amp;**  
    *[1] 4712*  
    **# kill -s TERM 4712**                  - то же самое, что *kill -15 4712*  
    **# killall -1 httpd**                   - Завершить процессы HUP по точному имени  
    **# pkill -9 http**                      - Завершить процессы TERM по (части) имени  
    **# pkill -TERM -u www**                 - Завершить процессы TERM, принадлежащие пользователю www  
    **# fuser -k -TERM -m /home**            - Завершить все процессы, обращающиеся к /home (для отмонтирования)  

!!! info "Важные сигналы:"
    1 &nbsp; &nbsp; &nbsp; HUP (завершение соединения)  
    2 &nbsp; &nbsp; &nbsp; INT (прерывание)  
    3 &nbsp; &nbsp; &nbsp; QUIT (выход)  
    9 &nbsp; &nbsp; &nbsp; KILL (неперехватываемое, невозможно игнорировать завершение)  
    15 &nbsp; &nbsp; TERM (сигнал программного завершения)  
